<?php\n// handlers/game_handler.php\n\nfunction handleGetTablesStatus($pdo, $userId) {\n    // 这是一个复杂的查询，需要根据我们讨论的逻辑来实现\n    // 简化逻辑：查询每个桌子(1-6)最新一个未完成的场次状态\n    $tablesStatus = [];\n    for ($i = 1; $i <= 6; $i++) {\n        $stmt = $pdo->prepare("\n            SELECT b.id as batch_id, COUNT(ps.user_id) as player_count, b.status\n            FROM game_batches b\n            LEFT JOIN batch_player_status ps ON b.id = ps.batch_id\n            WHERE b.table_id = ? AND b.status != 'completed'\n            GROUP BY b.id, b.status\n            ORDER BY b.batch_number DESC LIMIT 1\n        ");\n        $stmt->execute([$i]);\n        $batch = $stmt->fetch();\n\n        $score_type_map = [1 => 2, 2 => 2, 3 => 5, 4 => 5, 5 => 10, 6 => 10];\n        $table_number_map = [1 => 1, 2 => 2, 3 => 1, 4 => 2, 5 => 1, 6 => 2];\n        \n        if ($batch) {\n             $status = ($batch['player_count'] >= 4) ? 'in_game' : 'waiting';\n             // 这里需要更精确的状态判断，比如从 batch_player_status 中判断\n             $tablesStatus[] = [\n                'table_id' => $i,\n                'score_type' => $score_type_map[$i],\n                'table_number' => $table_number_map[$i],\n                'status' => $status,\n                'players_current' => (int)$batch['player_count'],\n                'players_needed' => 4,\n            ];\n        } else {\n            // 没有活跃场次，桌子空闲\n            $tablesStatus[] = [\n                'table_id' => $i,\n                'score_type' => $score_type_map[$i],\n                'table_number' => $table_number_map[$i],\n                'status' => 'waiting',\n                'players_current' => 0,\n                'players_needed' => 4,\n            ];\n        }\n    }\n    \n    echo json_encode(['success' => true, 'tables' => $tablesStatus]);\n}\n\n// 此处应有 handleJoinTable, handleGetNextCard, handleSubmitHand 等函数\n// 它们的逻辑会严格遵循我们之前讨论的数据库交互流程